## Answers

1. Because large projects often rely on many libraries. Managing dependencies ensures compatibility, stability, and reproducibility.
2. It means the software was tested with that version, and other versions may introduce bugs, break compatibility, or behave differently.
3. A versioning system in the format MAJOR.MINOR.PATCH indicating the type of changes in the software.
4. When making bug fixes that do not affect functionality or APIs.
5. When adding new features in a backward-compatible manner.
6. When making backward-incompatible changes that may break existing users’ code.
7. A file that records the exact versions of dependencies used in a project to ensure reproducibility across systems.
8. It prevents dependency updates from introducing bugs or inconsistencies by "locking" the versions used.
9. It avoids reinstalling or resolving dependencies each time, reducing build and deploy time.
10. A Continuous Integration process that automatically builds, tests, and validates code whenever changes are pushed.
11. Running test suites on every pull request to catch bugs early.
12. A tool that scans your project for outdated or vulnerable dependencies and automatically opens PRs to update them.
13. A static site hosting service for repositories.
14. A collection of automated tests that check whether code behaves as expected.
15. A test that verifies a small, isolated piece of code (usually a single function or method).
16. A test that checks how multiple components or systems work together.
17. A test that ensures that debugged functionalities don't break again.
18. Replacing real components with fake versions to isolate the unit under test and simplify the testing process.
19. It enables teams to coordinate around stable versions, preventing unexpected changes from breaking each other’s code.
20. Metaprogramming can automate test generation, mocking, or dynamic assertions—reducing boilerplate and increasing test coverage.
